// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Plain
#pragma kernel Atmo

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
struct Sphere
{
	float3 pos;
    float radius, gravity;
    float3 color;
    float3 vel;
    float2 atmo;
    float3 atmoCol;
};

float3 RotateVec(float3 input, float theta, float psi)
{
    float3 psiChange = float3(input.x, input.y * cos(psi) - input.z * sin(psi), input.y * sin(psi) + input.z * cos(psi));
    float3 thetaChange = float3(psiChange.x * cos(theta) + psiChange.z * sin(theta), psiChange.y, psiChange.z * cos(theta) - psiChange.x * sin(theta));
    return thetaChange;
}

float3 Overbright(float3 col)
{
    float maxi = max(max(col.x, col.y), col.z);
    if (maxi < 1)
        return col;
    return lerp(float3(1, 1, 1), col / maxi, 1 / (maxi * maxi));
}

bool blueshiftEnabled;
float3 Blueshift(float3 input, float strength)
{
    //strength *= blueshiftMult;
    if (abs(strength) < 0.006 || !blueshiftEnabled)
    {
        return input;
    }
    strength = clamp(strength, -3, 3);
    
    input *= exp2(strength);
    float3 result = input;
    
    if (strength > 0)
    {
        if (strength > 2)
        {
            result.b = result.r * (3.0 - strength);
            result.g = 0;
            result.r = 0;
        }
        else if (strength > 1)
        {
            result.r = 0;
            result.g = input.r * (2.0 - strength);
            result.b = lerp(input.g, input.r, strength - 1.0);
        }
        else
        {
            result.r = input.r * (1.0 - strength);
            result.g = lerp(input.g, input.r, strength);
            result.b = lerp(input.b, input.g, strength);
        }
    }
    else
    {
        strength *= -1;
        if (strength > 2)
        {
            result.r = result.b * (3.0 - strength);
            result.g = 0;
            result.b = 0;
        }
        else if (strength > 1)
        {
            result.b = 0;
            result.g = input.b * (2.0 - strength);
            result.r = lerp(input.g, input.b, strength - 1.0);
        }
        else
        {
            result.r = lerp(input.r, input.g, strength);
            result.g = lerp(input.g, input.b, strength);
            result.b = input.b * (1.0 - strength);
        }
    }
    
    return result;
}
bool shadows;
bool equirect;

Texture2D skybox;
int2 skyboxDimensions;

RWStructuredBuffer<Sphere> sp;
RWTexture2D<float4> Result;

float3 camVel;
float3 lightDir;
float2 camAng;
//float2 skyAng;

float solarLuminosity;
float exposure;
float2 dimensions;
float normalDim;
float brightness;

float3 Projection(int2 id)
{
    if (equirect)
        return RotateVec(RotateVec(float3(0, 0, 1), (id.x - dimensions.x) / dimensions.x * 3.1415, -(id.y - dimensions.y) / dimensions.y * 1.571), camAng.x, camAng.y);
    
    return RotateVec(normalize(float3((id - dimensions) / normalDim
                    , 1)), camAng.x, camAng.y);
}

float4 SkyBox(float3 ray)
{
    float sunNess = 0.0074 / max(pow(distance(ray, lightDir) * 1.5, 1.76), 0.002) * solarLuminosity - 0.03;
    float4 s = float4(1.0, 0.96, 0.94, 1) * max(0, sunNess);
    
    //if (skyAng.x != 0 || skyAng.y != 0)
        //ray = RotateVec(ray, skyAng.x, skyAng.y);
    int lon = (atan2(ray.z, ray.x) / 6.28318530718 + 0.5) * skyboxDimensions.x;
    int lat = (asin(ray.y / length(ray)) / 3.1415926 + 0.5) * skyboxDimensions.y;
    s += skybox.Load(int3(lon, lat, 0)) * brightness;
    
    return float4(s.rgb, 1);
}

float3 hmod(float3 a, float b)
{
    return (abs(a) + float3(b * 0.5, b * 0.5, b * 0.5)) % float3(b, b, b) - float3(b * 0.5, b * 0.5, b * 0.5);
}

[numthreads(32,32,1)]
void Plain (uint3 id : SV_DispatchThreadID)
{
	// TODO: insert actual code here!
	float3 col = float3(0, 0, 0);
    float3 ray = float3(0, 0, 0);
    float3 rayDir = Projection(id.xy);
    
    float bleushit = dot(rayDir, camVel);
    rayDir = normalize(rayDir - camVel * 0.3);
    
	uint number;
    uint hitId = 4294967295;
	{
		uint stride = 0;
		sp.GetDimensions(number, stride);
	}
	
    bool blackhole = false;
	//Raymarch
	{
        bool collided = false;
		float tD = 0;
		float stepSize = 45000;
		while (tD < 30000 && stepSize > 0.001 && !blackhole && !collided)
		{
            float3 deflection = float3(0, 0, 0);
            
            float minDist = 100000;
            
            //if (abs(ray - sp[0].pos).y < 2000 && length(ray) < 4000)
            //{
            
            //    minDist = max(length(hmod(ray - sp[0].pos, 400))
            //- 30.0, 0.5);
            
            //    if (minDist < 1)
            //    {
            //        collided = true;
            //        col = float3(1, 0, 1);
            //    }
            //}
            
			for (uint i = 0; i < number; i++)
			{
				Sphere sph = sp[i];
				float3 delta = ray - sph.pos;
				float dst = max(length(delta) - sph.radius, 0);
				
				if (sph.gravity != 0)
                {
                    minDist = min(minDist, dst);
                        
                    float force = -pow(length(delta) / sph.gravity, -3);
                    
					if (force < -1)
                    {
                        blackhole = true;
                        hitId = i;
                    }
                    deflection += normalize(delta) * force;
                }
				
				if (sph.radius > 0 && !blackhole)
				{
                    minDist = min(minDist, dst + 0.003);

					if (dst < 0.003)
					{
                        float objectBlueshift = -dot(rayDir, sph.vel);
                        bleushit += objectBlueshift;
                        
                        hitId = i;
                        col = sph.color * solarLuminosity * saturate(dot(normalize(delta), lightDir));
                        collided = true;
					}
                }
			}
            minDist = min(minDist, 0.8 / length(deflection));
			stepSize = minDist;
            rayDir = normalize(rayDir + deflection * stepSize);
            
            bleushit -= dot(deflection, rayDir) * stepSize * 1.35;
			tD += stepSize;
			ray += rayDir * stepSize;
		}
		
        if (!collided && !blackhole)
            col = SkyBox(rayDir).rgb;
    }
	
	//Shadows
    if (hitId != 4294967295u && !blackhole && shadows)
	{
        float3 reflectionRayDirection = normalize(rayDir - 2 * normalize(ray - sp[hitId].pos) * dot(normalize(ray - sp[hitId].pos), rayDir));
        float3 reflectionRayOrigin = ray;
        rayDir = lightDir;
        
        {
            bool collided = false;
            float tD = 0;
            float stepSize = 15000;
            while (tD < 10000 && stepSize > 0.001 && !collided)
            {
                float3 deflection = float3(0, 0, 0);
                float minDist = 100000;
                for (uint i = 0; i < number; i++)
                {
                    if (i != hitId)
                    {
                        Sphere sph = sp[i];
                        float3 delta = ray - sph.pos;
                        float dst = max(length(delta) - sph.radius, 0);
				
                        if (sph.gravity != 0)
                        {
                            minDist = min(minDist, dst);
                        
                            float force = -pow(length(delta) / sph.gravity, -3);
                            if (force < -1)
                            {
                                collided = true;
                                col *= 0.2;
                                break;
                            }
                            deflection += normalize(delta) * force;
                        }
				
                        if (sph.radius > 0 && !collided)
                        {
                            minDist = min(minDist, dst + 0.003);

                            if (dst < 0.003)
                            {
                                col *= 0.2;
                                collided = true;
                                break;
                            }
                        }
                    }
                }
                minDist = min(minDist, 0.8 / length(deflection));
                stepSize = minDist;
                rayDir = normalize(rayDir + deflection * stepSize);
                tD += stepSize;
                ray += rayDir * stepSize;
            }
        }
        
        rayDir = reflectionRayDirection;
        ray = reflectionRayOrigin;
        
        float3 reflectionCol;
        uint reflHit = 4294967295u;
        {
            bool collided = false;
            float tD = 0;
            float stepSize = 15000;
            while (tD < 10000 && stepSize > 0.001 && !collided)
            {
                float3 deflection = float3(0, 0, 0);
                float minDist = 100000;
                for (uint i = 0; i < number; i++)
                {
                    if (i != hitId)
                    {
                        Sphere sph = sp[i];
                        float3 delta = ray - sph.pos;
                        float dst = max(length(delta) - sph.radius, 0);
				
                        if (sph.gravity != 0)
                        {
                            minDist = min(minDist, dst);
                        
                            float force = -pow(length(delta) / sph.gravity, -3);
                            if (force < -1)
                            {
                                collided = true;
                            }
                            deflection += normalize(delta) * force;
                        }
				
                        if (sph.radius > 0 && !collided)
                        {
                            minDist = min(minDist, dst + 0.003);

                            if (dst < 0.003)
                            {
                                float objectBlueshift = -dot(rayDir, sph.vel);
                                
                                reflectionCol = Blueshift(sph.color * solarLuminosity, objectBlueshift) * saturate(dot(normalize(delta), lightDir)) * 0.25;
                                reflHit = i;
                                collided = true;
                            }
                        }
                    }
                }
                minDist = min(minDist, 0.8 / length(deflection));
                stepSize = minDist;
                
                rayDir = normalize(rayDir + deflection * stepSize);
                tD += stepSize;
                ray += rayDir * stepSize;
            }
            
            if (!collided)
                reflectionCol = SkyBox(rayDir).rgb * 0.2;
            
            
            
            rayDir = lightDir;
            if (reflHit != 4294967295u)
            {
                bool collided = false;
                float tD = 0;
                float stepSize = 15000;
                while (tD < 6000 && stepSize > 0.001 && !collided)
                {
                    float3 deflection = float3(0, 0, 0);
                    float minDist = 100000;
                    for (uint i = 0; i < number; i++)
                    {
                        if (i != reflHit)
                        {
                            Sphere sph = sp[i];
                            float3 delta = ray - sph.pos;
                            float dst = max(length(delta) - sph.radius, 0);
				
                            if (sph.gravity != 0)
                            {
                                minDist = min(minDist, dst);
                        
                                float force = -pow(length(delta) / sph.gravity, -3);
                                if (force < -1)
                                {
                                    collided = true;
                                    reflectionCol *= 0.2;
                                }
                                deflection += normalize(delta) * force;
                            }
				
                            if (sph.radius > 0 && !collided)
                            {
                                minDist = min(minDist, dst + 0.003);

                                if (dst < 0.003)
                                {
                                    reflectionCol *= 0.2;
                                    collided = true;
                                }
                            }
                        }
                    }
                    minDist = min(minDist, 0.8 / length(deflection));
                    stepSize = minDist;
                    rayDir = normalize(rayDir + deflection * stepSize);
                    tD += stepSize;
                    ray += rayDir * stepSize;
                }
            }
            
            col += reflectionCol * sp[hitId].color;
        }
        
    }
    col = Blueshift(col, bleushit) * exposure;
    Result[id.xy] = float4(Overbright(col), 1);
}
float smin(float a, float b, float k)
{
    float h = clamp(0.5 + 0.5 * (a - b) / k, 0.0, 1.0);
    return lerp(a, b, h) - k * h * (1.0 - h);
}
[numthreads(32,32,1)]
void Atmo (uint3 id : SV_DispatchThreadID)
{
	// TODO: insert actual code here!
	float3 col = float3(0, 0, 0);
    float3 ray = float3(0, 0, 0);
    float3 rayDir = Projection(id.xy);
    
    float bleushit = dot(rayDir, camVel);
    rayDir = normalize(rayDir - camVel * 0.3);
    
	uint number;
    uint hitId = 4294967295;
	{
		uint stride = 0;
		sp.GetDimensions(number, stride);
	}
	
    bool blackhole = false;
	//Raymarch
    float3 atmoCol = float3(0, 0, 0);
    float transparency = 1;
    float reflTransparency = 0;
    {
        bool collided = false;
        float tD = 0;
        float stepSize = 45000;
        while (tD < 30000 && stepSize > 0.001 && transparency > 0.003)
        {
            float3 deflection = float3(0, 0, 0);
            float minDist = 100000;
            for (uint i = 0; i < number; i++)
            {
                Sphere sph = sp[i];
                float3 delta = ray - sph.pos;
                float dst = max(length(delta) - sph.radius, 0);
				
                if (sph.gravity != 0)
                {
                    minDist = min(minDist, dst);
                        
                    float force = -pow(length(delta) / sph.gravity, -3);
                    
                    if (force < -1)
                    {
                        //if (i == 0)
                        //{
                        //    ray = delta * sp[1].gravity + sp[1].pos;
                        //    rayDir = normalize(rayDir - 2 * normalize(delta) * dot(normalize(delta), rayDir));
                        //}
                        //else if (i == 1)
                        //{
                        //    ray = delta * sp[0].gravity + sp[0].pos;
                        //    rayDir = normalize(rayDir - 2 * normalize(delta) * dot(normalize(delta), rayDir));
                        //}
                        //else
                        //{
                            col *= 1.0 - transparency;
                            transparency = 0;
                        
                            blackhole = true;
                            hitId = i;
                        //}
                    }
                    deflection += normalize(delta) * force;
                }
				
                if (sph.radius > 0 && !blackhole)
                {
                    minDist = min(minDist, dst + 0.003);
                    
                    float objectBlueshift = -dot(rayDir, sph.vel);
                    if (dst < 0.003)
                    {
                        hitId = i;
                        col = lerp(col, Blueshift(sph.color * solarLuminosity, objectBlueshift) * saturate(dot(normalize(delta), lightDir)), transparency);
                        reflTransparency = transparency * transparency;
                        transparency = 0;
                        collided = true;
                    }
                    //{
                    //    float power = 1.0 / (1.0 + dst * 3.0);
                    //    col += sph.color * stepSize * power;
                    //    transparency *= 1.0 - power * 0.5;
                    //}
                    if (dst < (4 + max(sph.atmo.y, -1)) * sph.atmo.x * 2.0)
                    {   
                        float foo = exp(sph.atmo.y);
                        bool shadowA = false;
                        float pressure = exp(sph.atmo.y - 1.4 - dst / sph.atmo.x);
                        float3 aCol = sph.atmoCol;
                        float3 cCol = (1 - sph.atmoCol);
                        { //Main Body Shadow Cast
                            float3 rayN = ray + lightDir * (sph.atmo.x * 0.1 + foo * 0.035 + sph.radius * 0.013);
                            for (int j = 0; j < 8; j++)
                            {
                                float dstN = distance(rayN, sph.pos) - sph.radius;
                                if (dstN < 0)
                                {
                                    shadowA = true;
                                    j = 9;
                                }
                                else
                                {
                                    float opticalDensity = exp(sph.atmo.y - 1.65 - dstN / sph.atmo.x);
                                    aCol *= exp(-0.5 * opticalDensity);
                                    cCol *= exp(-0.5 * opticalDensity);
                                }
                                aCol *= saturate(dstN * 3.0 / sph.atmo.x);
                                cCol *= saturate(dstN * 3.0 / sph.atmo.x);
                                rayN += lightDir * (sph.atmo.x * 0.325 + foo * 0.07 + sph.radius * 0.036);
                            }
                        }
                        if (!shadowA) // Scattering & light extinction
                        {
                            float rayleighStrength = smin(dot(rayDir, lightDir), 0.025, -0.4);
                            float3 rayN = ray + lightDir * (sph.atmo.x * 0.1);
                            for (int j = 0; j < 6; j++)
                            {
                                float dstN = distance(rayN, sph.pos) - sph.radius;
                                if (dstN < 0)
                                {
                                    aCol *= 0;
                                    shadowA = true;
                                    j = 7;
                                }
                                else
                                {
                                    float opticalDensity = exp(sph.atmo.y - 1.65 - dstN / sph.atmo.x);
                                    
                                    aCol = lerp(aCol, cCol, opticalDensity * rayleighStrength * 1.8) * exp(-0.5 * opticalDensity);
                                    cCol *= exp(-0.5 * opticalDensity);
                                }
                                rayN += lightDir * (sph.atmo.x * 0.2 + foo * 0.02);
                            }
                        }
                        
                        if (!shadowA && pressure > 0.0005 && shadows)
                        {
                            float3 rayN = ray;
                            float3 rayDirN = lightDir;
                            float TDN = 0;
                            float stepSizeNew = 1;
                            int iter = 0;
                            while (TDN < 10000 && stepSizeNew > 0.1 && iter < 8)
                            {
                                float minDistN = 29032;
                                iter++;
                                
                                for (uint z = 0; z < number; z++)
                                {
                                    if (z != i)
                                    {
                                        Sphere s = sp[z];
                                        float dstN = distance(rayN, s.pos);
                                        rayDirN -= normalize(rayN - s.pos) * pow(dstN / s.gravity, -3);
                                        
                                        dstN = max(dstN - s.radius, 0);
                                        aCol *= saturate(1 - exp(s.atmo.y - 1.3 - dstN / s.atmo.x));
                                        minDistN = min(minDistN, dstN);
                                    }
                                }
                                rayDirN = normalize(rayDirN);
                                stepSizeNew = minDistN;
                                rayN += rayDirN * stepSizeNew;
                                TDN += stepSizeNew;
                            }
                            if (stepSizeNew <= 0.1)
                                aCol *= 0.1;
                        }
                        atmoCol += Blueshift(aCol * solarLuminosity, objectBlueshift + bleushit) * saturate(pressure * minDist / sph.atmo.x) * transparency;
                        transparency *= 1 - saturate(pressure * minDist / sph.atmo.x);
                    }
                }
            }
            minDist = min(minDist * 0.8236, 0.8 / length(deflection));
            stepSize = minDist;
            rayDir = normalize(rayDir + deflection * stepSize);
            
            bleushit -= dot(deflection, rayDir) * stepSize * 1.35;
            tD += stepSize;
            ray += rayDir * stepSize;
        }
		
        col = lerp(col, SkyBox(rayDir).rgb, transparency);
    }
	//Shadows
    
    if (hitId != 4294967295u && !blackhole && shadows)
    {
        float3 reflectionRayDirection = normalize(rayDir - 2 * normalize(ray - sp[hitId].pos) * dot(normalize(ray - sp[hitId].pos), rayDir));
        float3 reflectionRayOrigin = ray;
        rayDir = lightDir;
        
        {
            bool collided = false;
            float tD = 0;
            float stepSize = 15000;
            while (tD < 10000 && stepSize > 0.001 && !collided)
            {
                float3 deflection = float3(0, 0, 0);
                float minDist = 100000;
                for (uint i = 0; i < number; i++)
                {
                    if (i != hitId)
                    {
                        Sphere sph = sp[i];
                        float3 delta = ray - sph.pos;
                        float dst = max(length(delta) - sph.radius, 0);
				
                        if (sph.gravity != 0)
                        {
                            minDist = min(minDist, dst);
                        
                            float force = -pow(length(delta) / sph.gravity, -3);
                            if (force < -1)
                            {
                                collided = true;
                                col *= 0.2;
                                break;
                            }
                            deflection += normalize(delta) * force;
                        }
				
                        if (sph.radius > 0 && !collided)
                        {
                            minDist = min(minDist, dst + 0.003);

                            if (dst < 0.003)
                            {
                                col *= 0.2;
                                collided = true;
                                break;
                            }
                        }
                    }
                }
                minDist = min(minDist, 0.8 / length(deflection));
                stepSize = minDist;
                rayDir = normalize(rayDir + deflection * stepSize);
                tD += stepSize;
                ray += rayDir * stepSize;
            }
        }
        
        rayDir = reflectionRayDirection;
        ray = reflectionRayOrigin;
        
        float3 reflectionCol;
        uint reflHit = 4294967295u;
        {
            bool collided = false;
            float tD = 0;
            float stepSize = 15000;
            while (tD < 10000 && stepSize > 0.001 && !collided)
            {
                float3 deflection = float3(0, 0, 0);
                float minDist = 100000;
                for (uint i = 0; i < number; i++)
                {
                    if (i != hitId)
                    {
                        Sphere sph = sp[i];
                        float3 delta = ray - sph.pos;
                        float dst = max(length(delta) - sph.radius, 0);
				
                        if (sph.gravity != 0)
                        {
                            minDist = min(minDist, dst);
                        
                            float force = -pow(length(delta) / sph.gravity, -3);
                            if (force < -1)
                            {
                                collided = true;
                            }
                            deflection += normalize(delta) * force;
                        }
				
                        if (sph.radius > 0 && !collided)
                        {
                            minDist = min(minDist, dst + 0.003);

                            if (dst < 0.003)
                            {
                                float objectBlueshift = -dot(rayDir, sph.vel);
                                
                                reflectionCol = Blueshift(sph.color * solarLuminosity, objectBlueshift) * saturate(dot(normalize(delta), lightDir)) * 0.25;
                                reflHit = i;
                                collided = true;
                            }
                        }
                    }
                }
                minDist = min(minDist, 0.8 / length(deflection));
                stepSize = minDist;
                
                rayDir = normalize(rayDir + deflection * stepSize);
                tD += stepSize;
                ray += rayDir * stepSize;
            }
            
            if (!collided)
                reflectionCol = SkyBox(rayDir).rgb * 0.2;
            
            reflectionCol *= reflTransparency * sp[hitId].color;
            
            rayDir = lightDir;
            if (reflHit != 4294967295u)
            {
                bool collided = false;
                float tD = 0;
                float stepSize = 15000;
                while (tD < 6000 && stepSize > 0.001 && !collided)
                {
                    float3 deflection = float3(0, 0, 0);
                    float minDist = 100000;
                    for (uint i = 0; i < number; i++)
                    {
                        if (i != reflHit)
                        {
                            Sphere sph = sp[i];
                            float3 delta = ray - sph.pos;
                            float dst = max(length(delta) - sph.radius, 0);
				
                            if (sph.gravity != 0)
                            {
                                minDist = min(minDist, dst);
                        
                                float force = -pow(length(delta) / sph.gravity, -3);
                                if (force < -1)
                                {
                                    collided = true;
                                    reflectionCol *= 0.2;
                                }
                                deflection += normalize(delta) * force;
                            }
				
                            if (sph.radius > 0 && !collided)
                            {
                                minDist = min(minDist, dst + 0.003);

                                if (dst < 0.003)
                                {
                                    reflectionCol *= 0.2;
                                    collided = true;
                                }
                            }
                        }
                    }
                    minDist = min(minDist, 0.8 / length(deflection));
                    stepSize = minDist;
                    rayDir = normalize(rayDir + deflection * stepSize);
                    tD += stepSize;
                    ray += rayDir * stepSize;
                }
            }
            
            col += reflectionCol;
        }
        
    }
    col = Blueshift(col, bleushit) + atmoCol * 1.2;
    Result[id.xy] = float4(Overbright(col * exposure), 1);
}
